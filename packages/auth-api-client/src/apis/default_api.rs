/*
 * Better Auth
 *
 * API Reference for your Better Auth Instance
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`change_email_post`]
#[derive(Clone, Debug)]
pub struct ChangeEmailPostParams {
    pub change_email_post_request: models::ChangeEmailPostRequest
}

/// struct for passing parameters to the method [`change_password_post`]
#[derive(Clone, Debug)]
pub struct ChangePasswordPostParams {
    pub change_password_post_request: models::ChangePasswordPostRequest
}

/// struct for passing parameters to the method [`delete_user_callback_get`]
#[derive(Clone, Debug)]
pub struct DeleteUserCallbackGetParams {
    pub token: Option<String>,
    pub callback_url: Option<String>
}

/// struct for passing parameters to the method [`delete_user_post`]
#[derive(Clone, Debug)]
pub struct DeleteUserPostParams {
    pub delete_user_post_request: models::DeleteUserPostRequest
}

/// struct for passing parameters to the method [`forget_password_post`]
#[derive(Clone, Debug)]
pub struct ForgetPasswordPostParams {
    pub forget_password_post_request: models::ForgetPasswordPostRequest
}

/// struct for passing parameters to the method [`link_social_post`]
#[derive(Clone, Debug)]
pub struct LinkSocialPostParams {
    pub link_social_post_request: models::LinkSocialPostRequest
}

/// struct for passing parameters to the method [`refresh_token_post`]
#[derive(Clone, Debug)]
pub struct RefreshTokenPostParams {
    pub refresh_token_post_request: models::RefreshTokenPostRequest
}

/// struct for passing parameters to the method [`reset_password_post`]
#[derive(Clone, Debug)]
pub struct ResetPasswordPostParams {
    pub reset_password_post_request: models::ResetPasswordPostRequest
}

/// struct for passing parameters to the method [`reset_password_token_get`]
#[derive(Clone, Debug)]
pub struct ResetPasswordTokenGetParams {
    /// The token to reset the password
    pub token: String,
    /// The URL to redirect the user to reset their password
    pub callback_url: String
}

/// struct for passing parameters to the method [`revoke_other_sessions_post`]
#[derive(Clone, Debug)]
pub struct RevokeOtherSessionsPostParams {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`revoke_session_post`]
#[derive(Clone, Debug)]
pub struct RevokeSessionPostParams {
    pub revoke_session_post_request: Option<models::RevokeSessionPostRequest>
}

/// struct for passing parameters to the method [`revoke_sessions_post`]
#[derive(Clone, Debug)]
pub struct RevokeSessionsPostParams {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`send_verification_email_post`]
#[derive(Clone, Debug)]
pub struct SendVerificationEmailPostParams {
    pub send_verification_email_post_request: Option<models::SendVerificationEmailPostRequest>
}

/// struct for passing parameters to the method [`sign_in_email_post`]
#[derive(Clone, Debug)]
pub struct SignInEmailPostParams {
    pub sign_in_email_post_request: models::SignInEmailPostRequest
}

/// struct for passing parameters to the method [`sign_out_post`]
#[derive(Clone, Debug)]
pub struct SignOutPostParams {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`sign_up_email_post`]
#[derive(Clone, Debug)]
pub struct SignUpEmailPostParams {
    pub sign_up_email_post_request: Option<models::SignUpEmailPostRequest>
}

/// struct for passing parameters to the method [`social_sign_in`]
#[derive(Clone, Debug)]
pub struct SocialSignInParams {
    pub social_sign_in_request: models::SocialSignInRequest
}

/// struct for passing parameters to the method [`unlink_account_post`]
#[derive(Clone, Debug)]
pub struct UnlinkAccountPostParams {
    pub unlink_account_post_request: models::UnlinkAccountPostRequest
}

/// struct for passing parameters to the method [`update_user_post`]
#[derive(Clone, Debug)]
pub struct UpdateUserPostParams {
    pub update_user_post_request: Option<models::UpdateUserPostRequest>
}

/// struct for passing parameters to the method [`verify_email_get`]
#[derive(Clone, Debug)]
pub struct VerifyEmailGetParams {
    /// The token to verify the email
    pub token: String,
    /// The URL to redirect to after email verification
    pub callback_url: Option<String>
}


/// struct for typed errors of method [`change_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeEmailPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangePasswordPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_callback_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserCallbackGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`error_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ErrorGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`forget_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ForgetPasswordPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`link_social_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkSocialPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountsGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sessions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSessionsGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ok_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OkGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`refresh_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshTokenPostError {
    Status400(),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetPasswordPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_password_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetPasswordTokenGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_other_sessions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeOtherSessionsPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_session_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeSessionPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_sessions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeSessionsPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_verification_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendVerificationEmailPostError {
    Status400(models::SendVerificationEmailPost400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sign_in_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SignInEmailPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sign_out_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SignOutPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sign_up_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SignUpEmailPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`social_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SocialSignInError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlink_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkAccountPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserPostError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_email_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyEmailGetError {
    Status400(models::SocialSignIn400Response),
    Status401(models::SocialSignIn400Response),
    Status403(models::SocialSignIn403Response),
    Status404(models::SocialSignIn403Response),
    Status429(models::SocialSignIn403Response),
    Status500(models::SocialSignIn403Response),
    UnknownValue(serde_json::Value),
}


pub async fn change_email_post(configuration: &configuration::Configuration, params: ChangeEmailPostParams) -> Result<models::ChangeEmailPost200Response, Error<ChangeEmailPostError>> {

    let uri_str = format!("{}/change-email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.change_email_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeEmailPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeEmailPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the password of the user
pub async fn change_password_post(configuration: &configuration::Configuration, params: ChangePasswordPostParams) -> Result<models::ChangePasswordPost200Response, Error<ChangePasswordPostError>> {

    let uri_str = format!("{}/change-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.change_password_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangePasswordPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangePasswordPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangePasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Callback to complete user deletion with verification token
pub async fn delete_user_callback_get(configuration: &configuration::Configuration, params: DeleteUserCallbackGetParams) -> Result<models::DeleteUserCallbackGet200Response, Error<DeleteUserCallbackGetError>> {

    let uri_str = format!("{}/delete-user/callback", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.callback_url {
        req_builder = req_builder.query(&[("callbackURL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteUserCallbackGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteUserCallbackGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserCallbackGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the user
pub async fn delete_user_post(configuration: &configuration::Configuration, params: DeleteUserPostParams) -> Result<models::DeleteUserPost200Response, Error<DeleteUserPostError>> {

    let uri_str = format!("{}/delete-user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_user_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteUserPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteUserPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays an error page
pub async fn error_get(configuration: &configuration::Configuration) -> Result<String, Error<ErrorGetError>> {

    let uri_str = format!("{}/error", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ErrorGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a password reset email to the user
pub async fn forget_password_post(configuration: &configuration::Configuration, params: ForgetPasswordPostParams) -> Result<models::ForgetPasswordPost200Response, Error<ForgetPasswordPostError>> {

    let uri_str = format!("{}/forget-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.forget_password_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ForgetPasswordPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ForgetPasswordPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ForgetPasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the current session
pub async fn get_session_get(configuration: &configuration::Configuration) -> Result<models::GetSessionGet200Response, Error<GetSessionGetError>> {

    let uri_str = format!("{}/get-session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSessionGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSessionGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Link a social account to the user
pub async fn link_social_post(configuration: &configuration::Configuration, params: LinkSocialPostParams) -> Result<models::LinkSocialPost200Response, Error<LinkSocialPostError>> {

    let uri_str = format!("{}/link-social", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.link_social_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LinkSocialPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LinkSocialPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LinkSocialPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all accounts linked to the user
pub async fn list_accounts_get(configuration: &configuration::Configuration) -> Result<Vec<models::ListAccountsGet200ResponseInner>, Error<ListAccountsGetError>> {

    let uri_str = format!("{}/list-accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ListAccountsGet200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ListAccountsGet200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all active sessions for the user
pub async fn list_sessions_get(configuration: &configuration::Configuration) -> Result<Vec<models::Session>, Error<ListSessionsGetError>> {

    let uri_str = format!("{}/list-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Session&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Session&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSessionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check if the API is working
pub async fn ok_get(configuration: &configuration::Configuration) -> Result<models::OkGet200Response, Error<OkGetError>> {

    let uri_str = format!("{}/ok", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OkGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OkGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OkGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Refresh the access token using a refresh token
pub async fn refresh_token_post(configuration: &configuration::Configuration, params: RefreshTokenPostParams) -> Result<models::RefreshTokenPost200Response, Error<RefreshTokenPostError>> {

    let uri_str = format!("{}/refresh-token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.refresh_token_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RefreshTokenPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RefreshTokenPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RefreshTokenPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset the password for a user
pub async fn reset_password_post(configuration: &configuration::Configuration, params: ResetPasswordPostParams) -> Result<models::ForgetPasswordPost200Response, Error<ResetPasswordPostError>> {

    let uri_str = format!("{}/reset-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.reset_password_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ForgetPasswordPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ForgetPasswordPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetPasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redirects the user to the callback URL with the token
pub async fn reset_password_token_get(configuration: &configuration::Configuration, params: ResetPasswordTokenGetParams) -> Result<models::ResetPasswordTokenGet200Response, Error<ResetPasswordTokenGetError>> {

    let uri_str = format!("{}/reset-password/{token}", configuration.base_path, token=crate::apis::urlencode(params.token));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("callbackURL", &params.callback_url.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResetPasswordTokenGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResetPasswordTokenGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetPasswordTokenGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke all other sessions for the user except the current one
pub async fn revoke_other_sessions_post(configuration: &configuration::Configuration, params: RevokeOtherSessionsPostParams) -> Result<models::RevokeOtherSessionsPost200Response, Error<RevokeOtherSessionsPostError>> {

    let uri_str = format!("{}/revoke-other-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RevokeOtherSessionsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RevokeOtherSessionsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeOtherSessionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke a single session
pub async fn revoke_session_post(configuration: &configuration::Configuration, params: RevokeSessionPostParams) -> Result<models::RevokeSessionPost200Response, Error<RevokeSessionPostError>> {

    let uri_str = format!("{}/revoke-session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.revoke_session_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RevokeSessionPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RevokeSessionPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeSessionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke all sessions for the user
pub async fn revoke_sessions_post(configuration: &configuration::Configuration, params: RevokeSessionsPostParams) -> Result<models::RevokeSessionsPost200Response, Error<RevokeSessionsPostError>> {

    let uri_str = format!("{}/revoke-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RevokeSessionsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RevokeSessionsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeSessionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a verification email to the user
pub async fn send_verification_email_post(configuration: &configuration::Configuration, params: SendVerificationEmailPostParams) -> Result<models::SendVerificationEmailPost200Response, Error<SendVerificationEmailPostError>> {

    let uri_str = format!("{}/send-verification-email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_verification_email_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SendVerificationEmailPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SendVerificationEmailPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendVerificationEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sign in with email and password
pub async fn sign_in_email_post(configuration: &configuration::Configuration, params: SignInEmailPostParams) -> Result<models::SignInEmailPost200Response, Error<SignInEmailPostError>> {

    let uri_str = format!("{}/sign-in/email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.sign_in_email_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignInEmailPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignInEmailPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SignInEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sign out the current user
pub async fn sign_out_post(configuration: &configuration::Configuration, params: SignOutPostParams) -> Result<models::SignOutPost200Response, Error<SignOutPostError>> {

    let uri_str = format!("{}/sign-out", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignOutPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignOutPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SignOutPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sign up a user using email and password
pub async fn sign_up_email_post(configuration: &configuration::Configuration, params: SignUpEmailPostParams) -> Result<models::SignUpEmailPost200Response, Error<SignUpEmailPostError>> {

    let uri_str = format!("{}/sign-up/email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.sign_up_email_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignUpEmailPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignUpEmailPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SignUpEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sign in with a social provider
pub async fn social_sign_in(configuration: &configuration::Configuration, params: SocialSignInParams) -> Result<models::SocialSignIn200Response, Error<SocialSignInError>> {

    let uri_str = format!("{}/sign-in/social", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.social_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SocialSignIn200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SocialSignIn200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SocialSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unlink an account
pub async fn unlink_account_post(configuration: &configuration::Configuration, params: UnlinkAccountPostParams) -> Result<models::ForgetPasswordPost200Response, Error<UnlinkAccountPostError>> {

    let uri_str = format!("{}/unlink-account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.unlink_account_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ForgetPasswordPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ForgetPasswordPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnlinkAccountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the current user
pub async fn update_user_post(configuration: &configuration::Configuration, params: UpdateUserPostParams) -> Result<models::UpdateUserPost200Response, Error<UpdateUserPostError>> {

    let uri_str = format!("{}/update-user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_user_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateUserPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateUserPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Verify the email of the user
pub async fn verify_email_get(configuration: &configuration::Configuration, params: VerifyEmailGetParams) -> Result<models::VerifyEmailGet200Response, Error<VerifyEmailGetError>> {

    let uri_str = format!("{}/verify-email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token", &params.token.to_string())]);
    if let Some(ref param_value) = params.callback_url {
        req_builder = req_builder.query(&[("callbackURL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyEmailGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyEmailGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyEmailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

